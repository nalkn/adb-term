#---------------------------------------------------------------------------------
# -*- coding: utf-8 -*-
# Python: 3.12.0
# Author: Killian Nallet
# Date: 14/06/2025
#---------------------------------------------------------------------------------


# Imports
import os
import sys
import json
import shutil
import zipfile
import logging
from dotenv import load_dotenv
from subprocess import run

# Load adb key events
from adb_keyevents import KeyMap


# Load env (for programs default paths)
load_dotenv()
adb_path = os.getenv("ADB_PATH")
aapt_path = os.getenv("AAPT_PATH")
apktool_path = os.getenv("APKTOOL_PATH")
xapktoapk_path = os.getenv("XAPKTOAPK_PATH")


# Create constants
current_dir_path = os.path.dirname(__file__)
temp_dir_path = os.path.join(current_dir_path, ".temp")
temp_extract_path = os.path.join(temp_dir_path, "extract")
adbterm_conf_path = os.path.join(current_dir_path, "adb-term-conf.json")
apks_folder_path = os.path.join(current_dir_path, "apps-apks")
device_downloads_path = "/storage/emulated/0/Download/" # refers to the termux internal storage : "~/storage/downloads/"
pc_downloads_path = os.path.join(current_dir_path, "adb-downloads")


# Configure logger
log = logging.getLogger(__name__)
log.setLevel("DEBUG")
fh = logging.FileHandler('adb_term.log')
fh.setLevel(logging.DEBUG)
log.addHandler(fh)
log.info("--- adb_term.py started ---")


# Create functions
def search_program(program:str, default_path:str):
    """Search a program in the PATH"""

    print(f"Searching {program} ...")

    # If program not in the path
    if shutil.which(program) is None:

        print(f"[!] {program} is not in the PATH")
        log.warning(f"{program} is not in the PATH")
        
        # If the program not in the PATH and his default_path is invalid 
        if not os.path.exists(default_path):
            print(f"[-] {program} is not found on your computer")
            log.critical(f"{program} is not found on your computer")
            exit()

        # If the program found with his default_path (in .env file), add it to the python env
        else:
            os.environ["PATH"] += ";"+os.path.dirname(default_path)
            print(f"[+] {program} found at {default_path}")
            log.info(f"{program} found at {default_path}")


def exec_cmd(command:list, get_result=False):
    """Execute a command and return if it sucessful executed (or his result)"""

    log.info(f"exec {command}")
    result = run(command, capture_output=True, text=True) # old : call(command, stdout=DEVNULL, stderr=STDOUT) == 0
    if get_result:
        return result
    else:
        return result.returncode == 0


def restart_adb():
    """Restart (or start) the adb server"""

    exec_cmd(["adb", "kill-server"])
    return exec_cmd(["adb", "start-server"])


def ping_host(host_ip:str):
    """Ping a host ip on the actual network"""

    return exec_cmd(["ping", host_ip, "-w", "750", "-n", "2"])


def adb_device():
    """Return a base adb command with the current connected adb device ip"""

    return ["adb", "-s", conf["ip"]]


def get_connected_devices():
    """Retrieve the list of currently connected adb devices"""

    # Get adb devices
    result = exec_cmd(["adb", "devices"], get_result=True)
    
    # Extract the connected devices from output lines
    device_list = []
    for line in result.stdout.splitlines():
        if "\tdevice" in line:
            device_id = line.split("\t")[0]
            device_list.append(device_id)

    return device_list


def check_conn():
    """Check the connexion status of the adb selected device"""

    # return adb_sh_send_key(KeyMap.zero) # none key
    return f"{conf['ip']}:{conf['port']}" in get_connected_devices()


def adb_sh_cmd(command:list, get_result=False):
    """Execute a command in the adb shell on a connected adb device"""

    return exec_cmd(adb_device() + ["shell"] + command, get_result)


def adb_sh_send_text(command:str):
    """Send text to a connected adb device"""
    
    return exec_cmd(adb_device() + ["shell", "input", "text", f"'{command}'"]) # send command (with spaces into)


def adb_sh_send_key(*keyevents:str, keycombination=False):
    """Send keyevent(s) to a connected adb device"""
    
    if keycombination:
        sendkeys_mode = "keycombination"
        if len(keyevents) > 2:
            raise ValueError("keycombination needs at least 2 keys to send")
    else:
        sendkeys_mode = "keyevent"
    
    return exec_cmd(adb_device() + ["shell", "input", sendkeys_mode, *keyevents])


def adb_sh_exec_cmd(command:str):
    """Send a text command to execute on a connected adb device (for a terminal app like termux)"""
    
    return adb_sh_send_text(command) and adb_sh_send_key(KeyMap.enter)


def _extract_apkm(apkm_path:str) -> list:
    """Extract .apk files from .apkm file"""
    # https://github.com/veryraregaming/Rares-Apkm-to-APK-GUI

    log.info(f"extracting .apkm file '{apkm_path}' to .apk files")

    # Create temp extract dir
    basename_apkm = os.path.splitext(os.path.basename(apkm_path))[0]
    extract_dir = os.path.join(temp_extract_path, basename_apkm)
    os.makedirs(extract_dir, exist_ok=True)

    # Copy the .apkm to a .zip
    zip_path = os.path.join(extract_dir, basename_apkm+'.zip')
    shutil.copy(apkm_path, zip_path)

    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_ref.extractall(extract_dir)

    # Remove temp zipfile
    os.remove(zip_path)

    # List .apk files
    return [os.path.join(extract_dir, f) for f in os.listdir(extract_dir) if f.endswith('.apk')]


def _convert_xapk(xapk_path:str):
    """Convert a .xapk file to a .apk file"""
    # https://github.com/LuigiVampa92/xapk-to-apk

    log.info(f"converting .xapk file '{xapk_path}' to .apk file")

    print(os.path.exists(sys.executable), os.path.exists(xapktoapk_path), os.path.exists(xapk_path))

    print(xapktoapk_path, [sys.executable, xapktoapk_path, xapk_path])
    result = exec_cmd([sys.executable, xapktoapk_path, xapk_path], get_result=True)
    if result.returncode != 0:
        print(result.stderr.split())

    #TODO: rÃ©soudre l'erreur du path
    """
    ['F:\\Apps\\Programs\\Python\\Python312\\python.exe:', "can't", 'open', 'file', "'C:\\\\Users\\\\killiannallet\\\\Desktop\\\\TickWatch", "5\\\\tools\\\\xapk-to-apk.py':", '[Errno', '2]', 'No', 'such', 'file', 'or', 'directory']
    """

    print(result.stdout.split())

    exit()

    #TODO: convert apk with xapk-to-apk.py
    NotImplementedError("[!] install .xapk files are not implemented yet")


def check_apk_format(apk_path:str) -> str | list:
    """Check format of the apk and extract or convert it to a .apk file if is needed"""

    # Get apk format
    apk_ext = os.path.splitext(apk_path)[1]

    # Check apk format
    if apk_ext == ".apk":
        apk_files = [apk_path]

    if apk_ext == ".apkm":
        apk_files = _extract_apkm(apk_path)

    if apk_ext == ".xapk":
        apk_files = _convert_xapk(apk_path)

    # Return new .apk file(s)
    return apk_files


def adb_install_apk(apk_files:list, replace_apk=False, allow_downgrade=False):
    """Install apk file(s) on a connected adb device"""

    # Check apk format
    for apk_file in apk_files:
        apk_ext = os.path.splitext(apk_file)[1]
        if apk_ext != ".apk":
            raise ValueError(f"apk format (.{apk_ext}) is not supported !")

    # Create install command
    if len(apk_files) > 1:
        install_command = ["install-multiple"] + apk_files
    else:
        install_command = ["install"] + apk_files

    # Add replace / downgrade adb args
    if replace_apk: install_command.insert(1, "-r")
    if allow_downgrade: install_command.insert(1, "-d")

    # Install apk
    return exec_cmd(adb_device() + install_command, get_result=True)


def extract_apk_id(apk_path:str):
    """Extract id from a .apk file"""

    # Extract package Id
    result = exec_cmd(["aapt", "dump", "badging", apk_path], get_result=True)
    if result.returncode != 0:
        print(f"[-] cannot find apk id ({result.stderr.strip()})")
        return None

    # Extract package id from stdout
    chrs_before, chrs_after = "package: name='", "' versionCode="
    id_chrs_before, id_chrs_after = result.stdout.find(chrs_before), result.stdout.find(chrs_after)
    package_id = result.stdout[id_chrs_before+len(chrs_before):id_chrs_after]

    return package_id


def adb_list_packages():
    """List all packages of a connected adb device"""

    # Get installed packages
    _packages_id = adb_sh_cmd(["pm", "list", "packages"], True)

    # Check returncode
    if _packages_id.returncode != 0:
        return []

    # Extract packages from result
    packages_id = []
    for line in _packages_id.stdout.splitlines():
        packages_id.append(line.split("package:")[1])

    return packages_id


def adb_push_path(src:str, trg:str = device_downloads_path):
    """Push a file or a directory of files to a connected adb device"""

    return exec_cmd(adb_device() + ["push", src, trg])


def adb_pull_path(src:str, trg:str = pc_downloads_path):
    """Pull a file or a directory of files from a connected adb device"""

    return exec_cmd(adb_device() + ["pull", src, trg])


def adb_disable_dev_opts():
    """Disable the dev options on a connected adb device"""

    return exec_cmd(adb_device() + ["shell", "settings", "put", "global", "development_settings_enabled", "0"])


def save_conf(conf_to_save:dict):
    """Save the actual conf in a json file"""

    with open(adbterm_conf_path, "w") as file:
        json.dump(conf_to_save, file, indent=4)


# Search adb and start it
search_program("adb", adb_path)
print(f"[*] starting adb")
restart_adb()

# Search aapt
search_program("aapt", aapt_path)

# Search apktool
search_program("apktool", apktool_path)
if "JAVA_HOME" not in os.environ:
    print("[!] java is not in your env variable (JAVA_HOME) and it needed by apktool"); exit()

# Search xapk-to-apk.py
if os.path.exists(xapktoapk_path):
    print("[!] xapk-to-apk.py is not found on your computer"); exit()


# Check program conf
if os.path.exists(adbterm_conf_path):
    with open(adbterm_conf_path, "r") as file_conf: # load conf
        conf = json.load(file_conf)

# Pair new device and write conf
else:
    # Get pair infos
    print("[*] pair a new device")
    conf = {}
    conf["ip"] = input("[?] device ip: ")
    conf["port"] = None
    conf["start-apps"] = {}
    pair_port = input("[?] device pair port: ")
    pair_code = input("[?] device pair code: ")
    save_conf(conf)

    # Pair device
    if exec_cmd(["adb", "pair", conf["ip"]+":"+pair_port, pair_code]):
        print("[+] new device paired")
    else: 
        print("[-] pair of new device failed !"); exit()


# Connect device loop
while True:

    # Search device
    print(f"\nSearching device {conf["ip"]}")
    ping_ip = ping_host(conf["ip"]) # ping ip (check if ip is valid on the local network)
    if ping_ip:
        # Connect device
        print("[*] connecting to device")
        if not check_conn():
            # Check port
            if conf["port"] is None:
                conf["port"] = input("[?] device connect port: ")
                save_conf(conf)
            
            # Try connect
            exec_cmd(["adb", "connect", conf["ip"]+":"+conf["port"]])
            device_connected = check_conn() # test shell access

    else:
        print("[!] device not found")
        device_connected = False

    # Retype and save device infos
    if conf["port"] is None or not device_connected:
        # Print failes
        print("[-] connect device failed") if conf["port"] is not None else None

        # Try to connect a new port
        print("[*] input device infos :")
        if not ping_ip:
            ip = input(f"[?] device ip ({conf['ip']}) -> ")
            conf["ip"] = ip if ip != "" else conf["ip"]
        
        connect_port = input("[?] device connect port: ")
        conf["port"] = connect_port if connect_port != "" else conf["port"]
        save_conf(conf)

    # Device connected
    else:
        print("[+] device connected\n")
        break


# Loop for send commands
print(f"[*] session started with {conf['ip']}")

while True:

    # Get command
    try: cmd = input("> ").strip()
    except KeyboardInterrupt: send_crtlc = True
    else: send_crtlc = False

    # Check connexion
    if not check_conn():
        print("[!] device disconnected -> exit")
        break #? reconnect

    # Ctrl-C
    if send_crtlc:
        adb_sh_send_key(KeyMap.ctrl_right, KeyMap.c, keycombination=True)
        print("\r[KeyboardInterrupt] -> ctrl-c send to device")
        continue


    # No command
    if cmd == "":
        adb_sh_send_key(KeyMap.enter) # enter

    # Quit this program
    elif cmd == "quit":
        break


    # On / off screen
    elif cmd == "on":
        adb_sh_send_key(KeyMap.power)

    elif cmd == "off":
        adb_sh_send_key(KeyMap.endcall) # or soft_sleep


    # Disable dev options
    elif cmd == "dev-off":
        if adb_disable_dev_opts():
            print("-> dev options are disabled")


    # Start apps
    elif cmd.startswith("start "):
        # Get app to start
        app_to_find = cmd.split("start ")[1]

        # Start app
        if app_to_find in conf["start-apps"]:
            app_start_act = conf["start-apps"][app_to_find]
            print(f"[*] starting {app_to_find} app ({app_start_act})")
            if adb_sh_cmd(["am", "start", "-n", app_start_act]):
                print(f"[+] {app_to_find} app is started")
            else:
                print(f"[-] start of {app_to_find} app fail")
        else:
            print(
                f"[!] app '{app_to_find}' not found in the settings, to find a correct " +
                "app activity, you can install the app 'Activity Launcher' or use the command : " +
                "adb shell \"dumpsys package com.termux | grep -i Activity\""
            )


    elif cmd.startswith("test-devices"):
        # Test
        print(get_connected_devices())


    # Set user password
    elif cmd.startswith("set-passwd "):
        # Get passwd
        passwd = cmd.split("set-passwd ")[1]
        # Change passwd
        if adb_sh_exec_cmd("passwd") and adb_sh_exec_cmd(passwd) and adb_sh_exec_cmd(passwd): # retype password
            print("[*] password set")
            save_conf(conf)


    # Install apk
    elif cmd.startswith("install "):
        # Get apk
        apk_name = cmd.split("install ")[1]
        apk_exts = [".apk", ".apkm", ".xapk"]
        apk_names = [apk_name+ext for ext in apk_exts]
        apk_path = None

        # Check if the path is valid
        if os.path.exists(apk_name):
            if os.path.isfile(apk_name):
                apk_ext = os.path.splitext()[1]
                if apk_ext in apk_exts:
                    apk_path = apk_name
                else:
                    print(f"[!] .{apk_ext} files are not supported")
            else:
                print(f"[!] {apk_name} is not a file")

        # Search apk in apk dirs
        else:
            search_dirs = [apks_folder_path, os.path.join(apks_folder_path, "games")]
            for search_dir in search_dirs:
                for file in os.listdir(search_dir):
                    if apk_name == file:
                        pass
                    elif file in apk_names:
                        apk_name = file
                    else: 
                        continue
                    apk_path = os.path.join(current_dir_path, search_dir, apk_name)
                    break
                else:
                    continue
                break

        # Install apk
        if apk_path is not None:
            print(f"[*] installing '{apk_name}' on {conf["ip"]}")

            # Extract or convert the apk file if needed
            apk_files = check_apk_format(apk_path)

            # Check if the package is already installed
            replace_apk = False
            apk_id = extract_apk_id(apk_files[0])
            if (apk_id is not None) and (apk_id in adb_list_packages()):
                print("[!] This apk is already installed on device")
                if input("[?] Install the new apk without erasing old apk data (-> apk update) ? [y/n] ") in ["y", "yes"]:
                    replace_apk = True

            # Try install and get result
            print(f"[*] installing '{apk_name}'")
            result = adb_install_apk(apk_files, replace_apk)
            if result.returncode == 0: # no error
                print(f"[+] apk '{apk_name}' installed")

            # Error occured
            else:
                # Strip error
                err = result.stderr.strip()

                # Downgrade detected
                if "INSTALL_FAILED_VERSION_DOWNGRADE" in err and "Downgrade detected" in err:

                    # Try reinstall with downgrade
                    print("[!] Downgrade detected")
                    if input("[?] Install this old apk version ? [y/n] ") in ["yes", "y"]:
                        print(f"[*] installing '{apk_name}'")
                        result = adb_install_apk(apk_files, replace_apk, allow_downgrade=True)
                        if result.returncode == 0: # no error
                            print(f"[+] apk '{apk_name}' installed")
                        else:
                            print(f"[-] install apk failed ({result.stderr.strip()})")

                    # Install (downgrade) cancelled
                    else:
                        print(f"[-] install apk cancelled")

                # Other error in install apk
                else:
                    print(f"[-] install apk failed ({err})")

        # Apk not found
        else:
            print(f"[!] apk '{apk_name}' not found")


    # Push files
    elif cmd.startswith("push "):
        # Get file / dir
        src_path = cmd.split("push ")[1]

        # Check if the file exists
        if not os.path.exists(src_path):
            print(f"[!] the path {src_path} don't exists, cannot push this")
            continue

        # Check the "." to download a directory
        #if os.path.isdir(src_path) and not src_path.endswith("."):
        #    src_path += "." #? useful ?

        # Choose trg path
        print(f"[*] By default, push path to \"{device_downloads_path}\"")
        try: trg_path = input("[?] New target path (empty=default): ") or device_downloads_path
        except KeyboardInterrupt: continue

        # Send file
        print(f"[*] pushing '{src_path}' to the device")
        if adb_push_path(src_path, trg_path):
            print(f"[+] path pushed to \"{trg_path}\"")
        else:
            print("[-] push of path failed")


    # Pull files
    elif cmd.startswith("pull "):
        # Choose trg path
        print(f"[*] By default, path are pulled from \"{device_downloads_path}\"")
        try: src_device = input("[?] New source path (empty=default): ") or device_downloads_path
        except KeyboardInterrupt: continue

        # Get file / dir
        src_path = os.path.join(src_device, cmd.split("pull ")[1])

        # Check download dir
        if not os.path.exists(pc_downloads_path):
            os.mkdir(pc_downloads_path)
        
        # Pull file
        print(f"[*] pulling '{src_path}' from the device")
        if adb_pull_path(src_path):
            print(f"[+] path pulled to {pc_downloads_path}")
        else:
            print("[-] pull of path failed")


    # Actualize playlists
    elif cmd.startswith("playl-act "):
        # Get playlist name
        playlist_name = cmd.split("playl-act ")[1]
        #TODO: use the script to download playlists in the device
        print("[!] This fonctionnality is not implemented yet")


    # Execute command
    else:
        adb_sh_exec_cmd(cmd)
